import "pkg:/source/roku_modules/log/LogMixin.brs"
import "pkg:/source/core/Utils.bs"

interface focusableNode extends roSGNode
  optional isFocused as boolean
  optional drawFocusFeedback as boolean
end interface

' /**
'  * @module FocusManager
'  * @description Source of truth about application focus
'  */

function init() as void
  m.top.observeFieldScoped("_debugM", "onDebugMChange")
  m.log = new rlog.Logger("FocusManager")
  m.wasShown = false
  m.isKeyPressLocked = false
  m.lockedNode = invalid
  m.top.observeFieldScoped("focusTimerFire", "onFocusTimerFire")
end function

function onDebugMChange()
  mc.setOrAddNodeField(m.top, "__m", mc.private.getDebugMObject(m))
end function

'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'++ Protected api - only call from mixin
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

function _setFocusOn(node as focusableNode, isForced = false as boolean) as void
  m.log.verbose("setFocusOn", mc.dv(node))

  if m.top.enabled = false
    m.log.error("DISABLED: cannot set focus on", mc.dv(node))
    return
  end if

  if m.top.isLocked and not isChildOfLockedNode(node)
    if isForced
      m.log.warn("overriding setting m.locked focus (locked reason:", m.top.lockReason, ")")
    else
      m.log.warn("cannot set focus, it is locked on", mc.dv(m.lockedNode), "- reason :", m.top.lockReason)
      return
    end if
  end if

  if isValid(node)
    parents = getParents(node)

    if isInScene(parents)

      if m.top.isLogging
        m.log.info("setting focus to ", node.subType(), ".", node.id)
      end if

      _setFocusOnImpl(node, parents)
    else
      if m.top.invalidFocusSetsFocusOnMain
        m.log.error("set focus to an off scene node! - setting focus to MainScene. Node was", mc.dv(node))
        _setFocusOnImpl(m.top.getScene(), [])
      else
        m.log.error("set focus to an off scene node!", mc.dv(node))
        _setFocusOnImpl(node, parents)
      end if
    end if
  end if

end function

function isChildOfLockedNode(node as focusableNode) as boolean
  parents = getParents(node)
  for each parent in parents
    if parent.isSameNode(m.lockedNode)
      return true
    end if
  end for
  return false
end function

function _unsetFocusOn(node as focusableNode)
  m.log.info("manually unsetting focus on node")
  if m.top.enabled = true
    node.setFocus(false)
  else
    m.log.error("DISABLED cannot unset focus on", mc.dv(node))
  end if
end function

function _setFocusLocked(node as focusableNode, reason = "" as string) as void

  if m.top.enabled = false
    m.log.error("DISBALED: cannot set focuslocked on", mc.dv(node))
    return
  end if

  if node <> invalid
    _setFocusOn(node, true)
    m.lockedNode = node
    m.log.info("locking focus due to reason", reason)
    m.focusTimer.control = "start"
  else
    m.log.info("unlocking focus - previous m.lock reason:", m.top.lockReason)
    m.focusTimer.control = "stop"
    m.lockedNode = invalid
  end if

  m.top.lockReason = reason
  m.top.isLocked = m.lockedNode <> invalid
end function

function onFocusTimerFire()
  ' m.log.info("onFocusTimerFire")
  if m.top.enabled = true
    if m.focusedNode <> invalid
      m.focusedNode.setFocus(true)
    end if
  else
    m.log.error("DISABLED: cannot set focus on timer fire focusedNode", mc.dv(m.focusedNode))
  end if
end function

'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'++ private impl
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

function _setFocusOnImpl(node as focusableNode, parents as roArray) as void

  currentNode = m.top.focusedNode
  isCurrentNode = false
  if (node = invalid and currentNode = invalid) or (node <> invalid and node.isSamenode(currentNode))
    ' m.log.info("setting focus on same node - ignoring")
    if node <> invalid
      if node.doesExist("isFocused")
        node.isFocused = true
      end if
      if not node.isInFocusChain()
        isCurrentNode = true
      end if
    end if
    if not isCurrentNode
      return
    end if
  end if

  if currentNode <> invalid and not isCurrentNode
    ' m.log.info("setting focus on new node - unsetting focus on", currentNode.id)
    if currentNode.doesExist("isFocused") and currentNode.isFocused = true
      currentNode.isFocused = false
    end if

    setFieldOnNodes(m.parents, "isChildFocused", false, parents)
  end if

  m.top.focusedNode = node
  m.parents = parents

  if node <> invalid
    previousDrawFocusFeedback = false
    if node.doesExist("drawFocusFeedback")
      'bs:disable-next-line
      previousDrawFocusFeedback = node.drawFocusFeedback
      node.drawFocusFeedback = false
    end if

    node.setFocus(true)

    if node.doesExist("drawFocusFeedback")
      node.drawFocusFeedback = previousDrawFocusFeedback as boolean
    end if

    if node.doesExist("isFocused")
      ' m.log.info("setting node as focused, and telling parents", node.id)
      node.isFocused = true
    end if
    setFieldOnNodes(parents, "isChildFocused", true)
  else
    if m.top.invalidFocusSetsFocusOnMain
      m.log.error("set focus to an off scene node! - setting focus to MainScene")
    else
      m.log.error("set focus to invalid node! - in future this will set the focus to a backup-context node, to stop illegal focus scenarios")
    end if
  end if
end function

function getParents(node as focusableNode)
  if type(node) <> "roSGNode"
    return []
  end if

  parent = node.getParent()
  parents = []
  '// cspell:disable-next-line
  parentOids = {}
  maxDepth = 20
  i = 0
  while parent <> invalid and i < maxDepth

    if parent.subType() = "ModelLocator"
      m.log.warn("trying to focus on a view that is not yet on the view hierarchy")
      return []
    end if
    if parent._oid <> invalid
      '// cspell:disable-next-line
      if parentOids[parent._oid] <> invalid
        m.log.warn("for some reason this parent hierarchy was looping to infinity!")
        exit while
      end if
      '// cspell:disable-next-line
      parentOids[parent._oid] = true
    end if
    parents.push(parent)
    parent = parent.getParent()
    i++
  end while

  if i = maxDepth
    m.log.error("bailed on getParents after exceeding maxDepth", maxDepth)
  end if

  return parents
end function

function isValid(node as focusableNode)

  if mc.isUndefined(node)
    m.log.error("asked to focus on undefined node")
    return false
  else if node = invalid
    m.log.error("asked to focus on invalid node")
    return false
  else if type(node) <> "roSGNode"
    m.log.error("asked to focus on non rsGNode")
    return false
  end if

  return true
end function

function isInScene(parents as roArray)

  if parents.count() = 0
    m.log.error("asked to focus on node with no parents")
    return false
  end if

  lastParent = parents[parents.count() - 1]

  if not lastParent.isSubType("Scene")
    m.log.error("node is not in the scene")
    return false
  end if

  return true
end function

function setFieldOnNodes(nodes as roArray, field as string, value as dynamic, excludeParents = invalid as roArray)
  ' ? "--------------------------------START"

  for i = 0 to nodes.count() - 1
    node = nodes[i]
    ' ? i ; " " ; "id" ; " " ; node.id ; " " ; node[field] " > "; value
    if node.doesExist(field) and node[field] <> value
      if excludeParents = invalid or not excludeContains(excludeParents, node)
        ' ? field ; " " ; " " ; node[field] ; " " ; value
        node[field] = value
      end if
    end if

  end for
  ' ? "--------------------------------END"

end function

function excludeContains(array as roArray, value as dynamic) as boolean
  for each item in array
    if item.isSameNode(value)
      return true
    end if
  end for
  return false
end function
