import "pkg:/source/core/Utils.bs"
import "pkg:/source/roku_modules/log/LogMixin.brs"

namespace mc

  interface IComponentPooledNode extends roSGNode
    optional _mComponentType as string
  end interface

  interface IComponentPoolItem
    usedComponentsById as roAssociativeArray
    allComponents as roArray
    freeComponentsById as roAssociativeArray
    numberOfComponentsInPool as integer
  end interface

  ' all purpose component pool that can store any kind of components for reuse
  @node("mc_ComponentPool", "Group")
  class ComponentPool

    @observer("onDebugMChange")
    @alwaysnotify
    public _debugM = false
    public __m = {}
    public isCreateMoreEnabled = true
    public numberOfComponentsToCreateWhenDry = 10
    public numberOfComponentsInUse = 0
    public numberOfComponents = 0

    private poolsByComponentType = {}
    protected log
    private top as roSGNode

    function new()
      'bs:disable-next-line
      m.log = new rlog.Logger("ComponentPool")
      m.reset()
    end function

    private function onDebugMChange()
      m.log.error("dumping m")
      mc.setOrAddNodeField(m.top, "__m", mc.private.getDebugMObject(m))
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ public api
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function reset()
      m.log.info("reset")
      m.poolsByComponentType = {}
      m.numberOfComponents = 0
      m.numberOfComponentsInUse = 0
    end function

    function getComponentPool(componentType as string) as IComponentPoolItem
      pool = m.poolsByComponentType[componentType]
      if pool = invalid
        pool = {
          usedComponentsById: {}
          allComponents: []
          freeComponentsById: {}
          numberOfComponentsInPool: 0
        }
        m.poolsByComponentType[componentType] = pool
      end if
      return pool
    end function

    'RobotCell.hero
    function prebakeComponents(number as integer, componentType as string)
      m.log.info("adding ", number, componentType, "components")
      parts = componentType.split(".")
      compName = parts[0]
      pool = m.getComponentPool(componentType)

      for i = 0 to number - 1
        component = createObject("roSGNode", compName)
        if component <> invalid
          component.id = rnd(2147483647).toStr()
          mc.setOrAddNodeField(component, "_mComponentType", componentType)
          pool.numberOfComponentsInPool++
          pool.freeComponentsById[component.id] = component
          pool.allComponents.push(component)
          m.numberOfComponents++
        else
          m.log.error("error creating component with type", componentType)
        end if
      end for
    end function

    function getComponent(componentType as string, numToCreateIfDry = -1 as integer) as roSGNode

      pool = m.getComponentPool(componentType)

      if pool.freeComponentsById.count() = 0
        ' ? ">>>> RAN OUT OF " ; componentType
        m.log.warn("no free components of type :", componentType)
        if m.isCreateMoreEnabled
          if numToCreateIfDry = -1
            numToCreateIfDry = m.numberOfComponentsToCreateWhenDry
          end if
          m.log.warn("creating", numToCreateIfDry, "more", componentType, "components")

          numberOfComponents = m.numberOfComponents
          for i = 0 to numToCreateIfDry - 1
            component = m.createComponent(componentType)
            if component <> invalid
              pool.freeComponentsById[component.id] = component
              pool.numberOfComponentsInPool++
              pool.allComponents.push(component)
              numberOfComponents++
            else
              m.log.error("could not create component of type", componentType)
            end if
          end for
          m.numberOfComponents = numberOfComponents
        else
          return invalid
        end if
      end if

      id = invalid
      for each id in pool.freeComponentsById
        exit for
      end for

      if id <> invalid
        component = pool.freeComponentsById[id]
        pool.freeComponentsById.delete(id)
        pool.usedComponentsById[id] = component
        m.numberOfComponentsInUse++
        return component
      else
        m.log.error("could not get or create component of type ", componentType)
        return invalid
      end if
    end function

    function releaseComponent(component as IComponentPooledNode)
      if component <> invalid
        ' ? ">>>>releasing component "; mc.dv(component)
        if component.getParent() <> invalid
          component.getParent().removeChild(component)
        end if
        componentType = asString(component._mComponentType) <> "" ? component._mComponentType : component.subType()
        pool = m.getComponentPool(componentType)
        pool.usedComponentsById.delete(component.id)
        pool.freeComponentsById[component.id] = component
        m.numberOfComponentsInUse--
      end if
    end function

    function releaseComponents(components as roArray)
      for each component in components
        m.releaseComponent(component)
      end for
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ private impl
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function createComponent(componentType as string) as dynamic
      pool = m.getComponentPool(componentType)
      parts = componentType.split(".")
      compName = parts[0]
      component = createObject("roSGNode", compName)
      if component <> invalid
        mc.setOrAddNodeField(component, "_mComponentType", componentType)
        component.id = rnd(2147483647).toStr()
        pool.allComponents.push(component)
        pool.freeComponentsById[component.id] = component
      else
        m.log.error("could not create component of type", componentType)
      end if
      return component
    end function

  end class
end namespace
