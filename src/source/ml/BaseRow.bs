import "pkg:/source/ml/ListMixin.bs"
import "pkg:/source/ml/ItemDelegateMixin.bs"
import "pkg:/source/ml/RowItemScroller.bs"
import "pkg:/source/ml/RowItemViewManager.bs"
import "pkg:/source/ml/ItemFocusManager.bs"
import "pkg:/source/view/BaseView.bs"
import "pkg:/source/ml/CellInfo.bs"
import "pkg:/source/ml/FocusIndicatorConfig.bs"

namespace ml
  @node("ml_BaseRow", "mv_BaseView")
  class BaseRow extends mv.BaseView

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Pubic Fields
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    'Instance of RowContent
    @observer("_onContentChange")
    public content as mc.types.node

    public index = -1
    public renderState = "none"
    @observer("onIsRenderedChange")
    public isRendered = false
    public isInViewport = false
    public height = 0
    public width = 0
    public screenPos = 0

    'set this to true, if you have row content that changes other fields you want to know about in `onContentChange`
    public alwaysNotifyContentChange = false


    @alwaysnotify
    @observer("onJumpToIndex")
    public jumpToIndex = -1

    @alwaysnotify
    @observer("onAnimateToIndexChange")
    public animateToIndex = -1

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Event Delegation
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    @observer("onListEvent")
    public listEvent as mc.types.Assocarray
    public owner as mc.types.node

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Protected Fields
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    protected _content ' use this reference for speed
    protected isInitialized = false
    protected wasHidden = false
    protected wasFocusable = true
    protected settings
    protected rowInfos = []
    protected propagatedEvents = {}

    function new()
      super(m.top.subType())
      ml.itemDelegateMixin.setDelegate()
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ initialization
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    protected override function initialize()
      super.initialize()
      m.createViews()
      m.isInitialized = true
      m._onContentChange()
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ callbacks
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function _onContentChange()
      ' ? "ON CONTENT CHANGE "; m.isInitialized
      m.log.info("onContentChange")
      if m.isInitialized
        if m._content = invalid or not m._content.isSameNode(m.content)
          if m._content <> invalid
            m.unobserveNodeField(m._content, "changes", m.onContentItemsChange)
          end if
          'was no content or it changed
          m._content = m.content
          m.settings = ml.listMixin.getRowSettings(m.owner.content, m._content)

          'get propagation settings
          propagateEnterExit = m.settings.propagateEnterExit
          m.propagatedEvents["didEnter"] = propagateEnterExit
          m.propagatedEvents["didExit"] = propagateEnterExit

          propagateScroll = m.settings.propagateScroll
          m.propagatedEvents["scrollStart"] = propagateScroll
          m.propagatedEvents["scrollStop"] = propagateScroll

          propagateScrollUpdate = m.settings.propagateScrollUpdate
          m.propagatedEvents["scrollUpdate"] = propagateScrollUpdate

          m.observeNodeField(m._content, "changes", m.onContentItemsChange)
          m.onContentChange(m._content)

        else if m._content <> invalid
          changes = []
          if m.wasHidden <> m._content.isHidden
            ' ? ">>>>>>>>>>>>>>> IS HIDDEN CHANGE " ; m._content.isHidden
            changes.push({ row: m._content, type: "isHidden", value: m._content.isHidden })
            m.wasHidden = m._content.isHidden
          end if
          if m.wasFocusable <> m._content.isFocusEnabled
            changes.push({ row: m._content, type: "isFocusEnabled", value: m._content.isFocusEnabled })
            m.wasFocusable = m._content.isFocusEnabled
          end if

          if m.alwaysNotifyContentChange
            m.onContentChange(m._content)
          end if

          if changes.count() > 0
            m.owner@._onContentItemChange(changes)
          end if

          'potentially update the header
        else
          '   'new content is invalid
          m.wasHidden = true
          m.wasFocusable = false
        end if

      end if
    end function

    protected function onContentItemsChange(changes as mc.types.array)
      m.log.info("This content has changed in some way")
    end function


    public function onJumpToIndex(index as integer)
      if m.content <> invalid and index <> -1
        m.jumpToItem(index, false)
      end if
    end function

    public function onAnimateToIndexChange(index as integer)
      if m.content <> invalid and index <> -1
        m.jumpToItem(index, true)
      end if
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ public api
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    public function recycle(newContent as mc.types.node)
      m.onRecycle(newContent)
    end function

    public function forceUpdate(keepOldFocusIfPossible = true as boolean, fullUpdate = false as boolean) as void
      if m.owner = invalid or m._content = invalid
        return
      end if
      m.settings = ml.listMixin.getRowSettings(m.owner.content, m._content)
      m.onContentChange(m._content)

      'bs:disable-next-line
      if m.configureHeader <> invalid
        'bs:disable-next-line
        m.configureHeader(true)
      end if
    end function

    public function updateChangedItems()
      '  ? " Base row updateChangedItems"
      'bs:disable-next-line
      if m.viewManager <> invalid and m.viewManager.updateChangedItems <> invalid
        ' ? "invoking on view manager"
        'bs:disable-next-line
        m.viewManager.updateChangedItems()
      end if
    end function

    public function getRenderer(index as integer) as object
      'implement me
      return invalid
    end function

    public function getRect(index as integer, useScreenCoords = false as boolean) as object
      'implement me
      return invalid
    end function

    public function getRowInfos(forceRecalculate = false as boolean) as mc.types.array
      'bs:disable-next-line
      if m.viewManager <> invalid
        'bs:disable-next-line
        return m.viewManager.getRowInfos(m.top.translation[1], forceRecalculate = true)
      else
        focusSettings = m.settings.focusSettings

        screenPos = m.settings.screenPos
        yOffset = m.top.translation[1]

        positions = [
          new ml.CellPosition(yOffset, screenPos) 'normal
          new ml.CellPosition(yOffset, screenPos) 'float-scroll
        ]
        rowInfo = new ml.CellInfo([m.width, m.height], focusSettings, positions, false, m.index, 0)
        return [rowInfo]
      end if
    end function

    public function getFocusIndicatorConfig(CellInfo as ml.CellInfo, direction as integer, isFloatingFocus as boolean, isFromListScroll = false as boolean) as ml.FocusIndicatorConfig
      CellInfo = m.getRowInfos(false)[CellInfo.componentIndex]
      'bs:disable-next-line
      if m.itemScroller <> invalid
        'bs:disable-next-line
        return m.itemScroller.getFocusIndicatorConfig(CellInfo, direction, isFloatingFocus, isFromLIstScroll)
      else
        return new ml.FocusIndicatorConfig(m.index, -1, [0, 0], [0, 0], m.settings, true)
      end if
    end function

    public function chooseCellInfoForScrollingIntoRow(CellInfo as ml.CellInfo)
      'bs:disable-next-line
      if m.itemScroller <> invalid
        'bs:disable-next-line
        m.itemScroller.chooseCellInfoForScrollingIntoRow(CellInfo)
      end if
    end function

    public function isVerticalFlowFocusPossible(CellInfo as ml.CellInfo, direction as integer, activeScreenPos as integer, scrollPos as integer) as boolean
      'bs:disable-next-line
      if m.viewManager <> invalid
        'bs:disable-next-line
        return m.viewManager.isVerticalFlowFocusPossible(CellInfo, direction, activeScreenPos, scrollPos)
      end if
      return true
    end function

    public function focusOnContentsNow()
      ? " FOCUS  ON CONTENTS NOW " mc.dv(m.top)
      'bs:disable-next-line
      if m.itemScroller <> invalid
        'bs:disable-next-line
        config = m.itemScroller.getFocusIndicatorConfig(m.itemScroller.cellInfo, m.itemScroller.direction, false, false)
        'bs:disable-next-line
        m.owner.focusIndicatorManager@.setNextFocusIndicatorConfig(config)
        m.owner.focusIndicatorManager@.setFocusComplete(config)
      end if
    end function

    'sends a row data event back to the owning list
    protected function sendRowData(data as mc.types.assocarray)
      m.owner.listEvent = {
        name: "rowData"
        index: m.top.index
        data: data
      }
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ abstract methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    public function getItemSize(index as integer) as mc.types.array
      'implement me
      return invalid
    end function

    protected function onRecycle(newContent as mc.types.node)
      'implement me
    end function

    protected function createViews()
      'implement me
    end function

    protected function onContentchange(content as mc.types.node)
      'implement me
    end function

    protected function onIsRenderedChange()
      'implement me
    end function

    public function jumpToItem(index as integer, animated as boolean)
    end function

    protected function onListEvent(event as object)
    end function

    public function onFlowFocusFraction(fraction as float)
    end function

    public function getCellContainer()
      'implement me
    end function

  end class
end namespace
