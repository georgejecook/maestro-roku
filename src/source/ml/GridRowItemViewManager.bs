import "pkg:/source/ml/ItemViewManager.bs"
import "pkg:/source/ml/ComponentInfo.bs"

namespace ml
  class GridRowItemViewManager extends ml.ItemViewManager
    public row = invalid
    public numRows = 0
    public numCols = 1
    public componentBufferMode = "rendered"
    public lastRowIsRendered = "none"
    public isFlowSupported = false
    private maxRowPos = 0
    private rowOffsets = []
    private firstFlowIndex = 0
    private otherRowScreenPos = 0
    private perRowHeight = 0
    private isVerticalFlowFocusAllowed = false
    public upScreenPosition = 0
    public downScreenPosition = 0
    private lastFlowDirection = 1

    function new(list as mc.types.node, row as mc.types.node, container as mc.types.node, componentPool as mc.types.node, minPos as integer, maxPos as integer)
      super("GridRowItemViewManager", list, container, componentPool, 0, minPos, maxPos)
      m.row = row

      m.lookAheadDistance = maxPos * 1.5
      m.lookBehindDistance = maxPos * 1.5
    end function

    protected override function updateScreenRect()
      'bs:disable-next-line
      bounds = m.owner.sceneBoundingRect()
      m.screenRect = { translation: [bounds.x, bounds.y], size: [m.owner.width, m.maxRowPos] }
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Public Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function getRowIndexForItemIndex(index as integer) as integer
      return fix(index / m.numCols)
    end function

    function getCellInfosInRow(rowIndex as integer) as mc.types.array
      infos = []
      firstIndex = rowIndex * m.numCols
      for i = firstIndex to firstIndex + m.numCols - 1
        info = m.cellInfos[i]
        if info <> invalid
          infos.push(info)
        end if
      end for
      return infos
    end function

    function getRenderersInRow(rowIndex as integer) as mc.types.array
      infos = m.getCellInfosInRow(rowIndex)
      renderers = []
      for each info in infos
        renderer = m.getRenderer(info.componentIndex)
        if renderer <> invalid
          renderers.push(renderer)
        end if
      end for
      return renderers
    end function

    function getSubIndexAtPosition(position as integer, direction as integer)
      position += m.row.translation[1] 'adjust for position in the list
      p = abs(position)
      i = 0
      position -= m.contentGroup.translation[1] 'adjust for header offsets

      numRows = m.rowOffsets.count() - 1
      for i = numRows to 0 step -1
        ' ? " CHECK ROW " ;i ; " " ; m.rowOffsets[i] ; " >>> "; p
        itemPos = m.rowOffsets[i]
        if p > itemPos
          return mc.clamp(i + 1, 0, numRows)
        end if
      end for

      'we must be at the end! -return last item
      return mc.clamp(i, 0, numRows)
    end function


    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Overridden
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    protected override function getRowInfos(yPosition as integer, forceRecalculate = false as boolean) as mc.types.array
      if forceRecalculate
        m.rowInfos = invalid
      end if
      if m.rowInfos = invalid
        m.rowInfos = []

        height = m.owner.height

        rowHeight = m.settings.rowHeight
        contentOffset = m.settings.contentOffset[1]

        if m.settings.firstRowScreenPos <> m.settings.screenPos
          m.firstFlowIndex = 1
          m.otherRowScreenPos = m.settings.otherRowScreenPos
        else
          m.firstFlowIndex = 0
          m.otherRowScreenPos = m.settings.firstRowScreenPos
        end if
        m.maxRowPos = (m.settings.numRows - 1) * (m.perRowHeight)
        m.upScreenPosition = m.otherRowScreenPos

        if m.isVerticalFlowFocusAllowed
          m.downScreenPosition = m.maxRowPos
        else
          m.downScreenPosition = m.otherRowScreenPos
        end if
        m.updateScreenRect()

        ' ? "+>+>+>>+>+>++>+>+>+>>++>>+>+"
        for i = 0 to m.rowOffsets.count() - 1
          m.rowInfos.push(m.getRowInfo(i, [0, rowHeight], m.rowOffsets[i] - contentOffset, yPosition, height, m.maxRowPos))
          ' ? "LAYING OUT ITEM " ; i ; "RO " ; m.rowOffsets[i]
        end for
        ' ? "+>+>+>>+>+>++>+>+>+>>++>>+>+"
      end if
      return m.rowInfos
    end function

    public override function reset()
      m.log.info("releasing", m.renderersByContentId.count(), "row children")
      for each id in m.renderersByContentId
        m.componentPool@.releaseComponent(m.renderersByContentId[id])
      end for
      m.renderersByContentId = {}
      super.reset()
    end function

    override function createRenderers(content as mc.types.node, forceSync = false as boolean) as boolean
      'renderers are created as needed
      m.previousRendereredByContentId = m.renderersByContentId
      m.renderersByContentId = {}
      return true
    end function

    override function updateLayout(fullUpdate = false as boolean) as void
      m.log.info("GRID updateLayout")
      ' ? ""
      ' ? "+>+>>+>+>+>+>++>>++>>+>+>+>+>+>+>>+>+>+>+>"
      ' ? "GRID UPDATE LAYOUT"
      m.rects = []
      m.visibleItems = []
      m.rowOffsets = []
      m.rowInfos = invalid
      m.cellInfos = []
      m.isVerticalFlowFocusAllowed = m.getFocusSettings().vertAnimStyle = "floating"

      if m.content = invalid
        return
      end if

      i = 0
      xSpace = m.settings.space
      m.perRowHeight = m.settings.rowHeight + m.settings.rowSpace

      x = 0
      y = 0
      numItems = m.content.getChildCount()
      children = m.content.getChildren(-1, 0)
      m.numCols = m.settings.numColumns
      m.numCols = m.numCols < 1 ? 1 : m.numCols
      rowIndex = 0
      ' ? "children" ; formatJson(mc.collections.map(children, function(c as object)
      ' return c.title
      ' end function))

      ' ? "LAYING OUT+++++++++++++++++++++++++++++++++" ; m.numCols ; " perRowHeight "; m.perRowHeight

      renderedIds = {}
      while i < numItems
        m.rowOffsets.push(y)

        for col = 0 to m.numCols - 1
          item = children[i]
          if item = invalid
            exit for
          end if
          renderedIds[item.id] = true
          ' ? "ITEM " ; item.title
          settings = ml.listMixin.getCellSettings(m.owner.content, m.content, item)
          m.rects.push({
            translation: [x, y]
            size: settings.size
            index: i
            gridRow: rowIndex
            visible: true
          })

          positions = [
            new ml.ComponentPosition(0, x) 'up
            new ml.ComponentPosition(0, x) 'down
          ]

          cellInfo = new ml.ComponentInfo(settings.size, m.settings.focusSettings, positions, true, i, i)
          cellInfo.index = i
          m.cellInfos.push(cellInfo)
          'TODO - for now, no vis options for rows children..
          m.visibleItems.push(item)

          x += settings.size[m.axes] + xSpace
          i++
        end for

        x = 0
        y += m.perRowHeight
        rowIndex++
      end while

      ' ? "::>: ODL COUNT" ; m.renderersByContentId.count(), "NEW COUNT" ; renderedIds.count()
      if m.renderersByContentId.count() > renderedIds.count()
        m.log.warn("had dangling renderers - needs fixing")
        for each id in m.renderersByContentId
          if renderedIds[id] = invalid
            ' ? "::: it was removed"
            m.processRemovedItem(id)
          end if
        end for
      end if
      m.numRows = mc.clamp(m.rowOffsets.count() - 1, 0, m.settings.numRows)
      m.numberOfItems = m.visibleItems.count()
    end function

    private function getRowInfo(rowIndex as integer, size as mc.types.array, yOffset as integer, y as integer, height as integer, maxPos as integer) as ml.ComponentInfo

      yOffset += y

      if rowIndex = 0
        screenPos = m.settings.firstRowScreenPos
        ' ? " ROW 0 " ; screenPos
        ' if screenPos > yOffset
        '   screenPos = yOffset
        ' end if
        isFlowFocusAllowed = false

        positions = [
          new ml.ComponentPosition(yOffset, screenPos) 'up
          new ml.ComponentPosition(yOffset, screenPos) 'down
        ]
      else if rowIndex = 1 and m.settings.otherRowScreenPos <> m.settings.firstRowScreenPos
        screenPos = m.settings.otherRowScreenPos
        ' ? " ROW 1 " ; screenPos
        ' if screenPos > yOffset
        '   screenPos = yOffset
        ' end if
        isFlowFocusAllowed = false
        positions = [
          new ml.ComponentPosition(yOffset, screenPos) 'up
          new ml.ComponentPosition(yOffset, screenPos) 'down
        ]
      else
        screenPos = m.settings.otherRowScreenPos
        isFlowFocusAllowed = m.isVerticalFlowFocusAllowed
        if m.isVerticalFlowFocusAllowed
          downScreenPos = (m.settings.numRows - 1) * (m.perRowHeight)
        else
          downScreenPos = 0
        end if
        ' ? "ROW SCREEN POS" ; rowIndex ; " " ; yOffset ; " Y " ; yOffset ; " F "; m.firstFlowIndex ; " SP "; screenPos
        positions = [
          new ml.ComponentPosition(yOffset, screenPos) 'up
          ' new ml.ComponentPosition(yOffset, screenPos) 'down
          new ml.ComponentPosition(yOffset - downScreenPos, screenPos) 'down
        ]
      end if
      'note - col width is irrelevant
      return new ml.ComponentInfo(size, m.settings, positions, isFlowFocusAllowed, rowIndex, rowIndex)
    end function

    override function shouldUpdateRenderedIndexes(direction as integer, index as integer)
      return true
    end function

    override function applyRenderStateMap(renderStateMap as mc.types.assocarray)
      m.log.info("ROW applyRenderStateMap", m.row.index, m.row.isRendered)
      ' ? "______________________________ ARSM" ; m.__classname
      m.renderedComponents = []
      if m.row.isRendered
        for each id in renderStateMap
          m.applyrenderStateForCell(id, renderStateMap[id])
        end for
      else
        ' ? "ROW IS NOT !! RENDERED" ; m.row.index
        for each id in renderStateMap
          m.applyrenderStateForCell(id, "none")
        end for
      end if
      m.lastRowIsRendered = m.row.isRendered
    end function

    function applyrenderStateForCell(id as string, renderState as string)
      m.log.verbose("applyrenderStateForCell", id, renderState)
      index = id.toInt()
      ' isRendered = m.row.isRendered
      item = m.content.getChild(index)

      cell = invalid
      if item <> invalid
        itemId = item.id
        ' ? " GRID===========================" ; itemid
        if renderState = "rendered"
          cell = m.renderersByContentId[itemId]
          if cell = invalid
            cell = m.previousRendereredByContentId[itemId]
          end if
          if cell = invalid
            settings = ml.listMixin.getCellSettings(m.owner.content, m.content, item)
            ' ? "GETTING CELL " ; itemId ; " " ; settings.compName ; " " ; m.__classname
            cell = m.componentPool@.getComponent(settings.compName)

            if cell <> invalid
              cell.index = index
              cell.translation = m.rects[index].translation

              cell.initialState = {
                row: m.row
                list: m.owner
                size: m.rects[index].size
                content: item
              }

              cell.visible = true
              ' cell.visible = isRendered

              ' ? ">>>>>>>> is visible "

              ' if isRendered
              cell.listEvent = { "name": "didEnter" }
              ' end if

              if m.lastScrollEvent <> invalid
                cell.listEvent = m.lastScrollEvent
              end if

              m.container.appendChild(cell)
            else
              m.log.error("could not make cell of type ", settings.compName)
            end if
            m.previousRendereredByContentId.delete(itemId)
          else
            cell.translation = m.rects[index].translation
            ' might have changed
            cell.index = index
            cell.initialState = {
              row: m.row
              list: m.owner
              size: m.rects[index].size
              content: item
            }

            cell.visible = true
          end if
          if cell <> invalid
            ' ? " SET cell at index "; index ;" to " ; itemId; " " ; item.title
            ' ? " RENDERED COMPS IS NOW len" ; m.renderedComponents.count()
            m.renderedComponents.push(cell)
            m.previousRendereredByContentId.delete(itemId)
            m.renderersByContentId[itemId] = cell
          end if
        else
          cell = m.renderersByContentId[itemId]
          if cell <> invalid
            ' ? "RELEASING " ; id
            m.componentPool@.releaseComponent(cell)
            m.renderersByContentId.delete(itemId)
            m.previousRendereredByContentId.delete(itemId)
          else
            'this is almost certainly due to trying to release a cell during setting content
            ' ? " COULD NOT FIND CELL TO RELEASE" ; id
          end if
        end if
      end if
      componentConfig = m.cellInfos[index]
      componentConfig.component = cell
    end function

    override function getRenderer(index as integer)
      if m.content <> invalid
        item = m.content.getChild(index)
        if item <> invalid
          return m.renderersByContentId[item.id]
        else
          ' m.log.error("ERROR could not find renderer for ", index)
          ' ? " GRID COULD NOT GET RENDERER FOR index" ; index
          return invalid
        end if
      else
        return invalid
      end if
    end function

    override function setIsScrolling(isScrolling as boolean, isLong as boolean, startIndex as integer) as void
      if m.isScrolling = isScrolling
        return
      end if
      m.scrollingStartIndex = isScrolling ? startIndex: -1
      m.isScrolling = isScrolling

      ' ? "++++ setIsScrolling" ; isScrolling
      m.row.isScrolling = isScrolling

      m.owner.isScrolling = isScrolling

      event = {
        name: isScrolling ? "scrollStart" : "scrollStop"
        startIndex: m.scrollingStartIndex
        long: isLong
        startIndex: m.scrollingStartIndex
      }
      m.lastScrollEvent = isScrolling ? event : invalid


      for each id in m.renderersByContentId
        comp = m.renderersByContentId[id]
        comp.listEvent = event
      end for

      m.owner.listEvent = {
        name: event.name
        index: m.row.index
        long: isLong
        startIndex: startIndex
      }
      ' ? "++++ row - listEvent " ; formatJson(m.row.listEvent)
      ' ? "++++ owner - listEvent " ; formatJson(m.owner.listEvent)
    end function

    private function getHeightOfGridRow()

      return m.numRows * (m.settings.rowHeight + m.settings.space) + m.settings.headerSettings.height
    end function

    private function getLastRowOffset() as integer
      if m.rowOffsets.count() > 0
        return m.rowOffsets[m.rowOffsets.count() - 1]
      else
        return 0
      end if
    end function

    private function getRowOffset(rowIndex as integer) as integer
      if m.rowOffsets.count() > rowIndex
        return m.rowOffsets[rowIndex]
      else
        return 0
      end if
    end function

    override function getComponentsInViewPort(startOffset as integer)
      compStates = {}
      'NOTE - for now, all grid items are on screen - we can tighten it up later

      ' sStart = m.screenRect.translation[m.axes] + startOffset
      ' sEnd = sStart + m.screenRect.size[m.axes]

      for each comp in m.renderedComponents
        if comp.index <> invalid
          cRect = m.rects[comp.index]
          if cRect <> invalid
            compStates[comp.id] = true
            'TODO - minimize what is in view port
            '   cStart = cRect.translation[m.axes]
            '   cEnd = cStart + cRect.size[m.axes]
            '   if (cStart >= sStart and cStart <= sEnd) or (cEnd >= sStart and cEnd <= sEnd)
            '     compStates[comp.id] = true
            '   else
            '     compStates[comp.id] = false
            '   end if
          end if
        else
          ' ? "comp index not set!"
        end if
        ' m.log.info(compStates[comp.id], "sStart", sStart, "sEnd", sENd, "cStart", cStart, "cEnd", cENd)
      end for

      return compStates
    end function

    override function getRenderedIndexes(direction as integer, index as integer)
      return {
        startIndex: 0
        endIndex: m.content = invalid ? 0 : m.visibleItems.count() - 1
      }
    end function

    protected override function onContentItemsChange(changes as mc.types.array)
      m.log.info("updating row renderers due to contents change")

      ' ? " CHANGE GRID ROW " ; m.content.length ; " I " ; m.itemScroller.index
      numRows = m.rowOffsets.count()
      m.processRemovedCells(changes)
      m.forceUpdateLayout()

      m.updateRenderedComponents(m.itemScroller.direction, m.itemScroller.index, true)
      m.previousRendereredByContentId = m.renderersByContentId

      m.itemScroller.getComponentInfos(true)
      if m.itemScroller.index >= m.itemScroller.numberOfComponents
        m.itemScroller.index = mc.clamp(m.itemScroller.index, 0, m.itemScroller.numberOfComponents - 1)
        ' ? "NEEDED TWEAK TO index is now: " ; m.itemScroller.index
      end if
      if m.itemScroller.componentInfos.count() <> numRows
        m.itemScroller.chooseComponentInfoForScrollingIntoRow(m.itemScroller.componentInfos[m.itemScroller.index])
        ' ? "NEED TO TELL LIST!!!  num rows now " ; m.itemScroller.componentInfos.count()
        m.owner@.forceUpdate()
      end if

      m.itemScroller.processChanges(changes)
      if m.row.isFocused
        ' m.itemScroller.forceFocusOnIndex(m.itemScroller.index)
        ' m.owner.focusedCellIndex = m.itemScroller.index
        m.owner@.moveToRowItem(m.row.index, m.itemScroller.index, false)
      end if
    end function

    override function isVerticalFlowFocusPossible(info as ml.componentInfo, direction as integer, activeScreenPos as integer, scrollPos as integer)
      if not m.isVerticalFlowFocusAllowed
        return false
      end if
      ' ? " grid isVerticalFlowFocusPossible "
      ' ? info.componentIndex ; " NR "; m.settings.numRows ; " FRI " ; m.firstFlowIndex ; " ASP "; activeScreenPos ; " SP "; scrollPos

      if info.componentIndex <= m.firstFlowIndex and direction = 1
        return false
      end if

      activeScreenPos = m.lastFlowDirection = -1 ? m.upScreenPosition : m.downScreenPosition
      m.lastFlowDirection = direction

      ' ? " CHANGING ACTIVE SCREEN POS TO FIRST ROW POS"
      ' end if
      rowStartPos = scrollPos + activeScreenPos

      firstRowOnScreen = m.getSubIndexAtPosition(rowStartPos, direction)
      ' ? "L>>>>>>"
      ' ? "L>>>>>> ; first on screen" ; firstRowOnScreen
      ' ? "L>>>>>> ; last row ALLOWED screen "; firstRowOnScreen + (m.settings.numRows - 1)
      ' ? "L>>>>>> row "; info.componentIndex
      ' ? "L>>>>>> SP "; scrollPos ; " ASP "; activeScreenPos
      if direction = -1
        return info.componentIndex >= firstRowOnScreen
      else
        return info.componentIndex <= firstRowOnScreen + (m.settings.numRows - 1)
      end if
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Private Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function processRemovedCells(changes as mc.types.array)
      m.log.info("processing removed cells")
      for each change in changes
        ' ? "PRC GOT CHANGE TYPE "; change.type
        if change.type = "remove"
          ' m.log.info("removing cell at index", change.index)
          if change.child <> invalid
            m.processRemovedItem(change.child.id)
          else
            ' ? "NO CELL item.id", change.index
            m.log.error("could not find cell to release")
          end if
        end if
      end for
    end function

    private function processRemovedItem(id as string)
      ' ? " REMOVING CELL FOR ITEM ID "; id
      cell = m.renderersByContentId[id]
      if cell <> invalid
        ' ? " FOUND CELL AND REMOVED IT"
        m.componentPool@.releaseComponent(cell)
        m.renderersByContentId.delete(id)
      else
        'this is almost certainly due to trying to release a cell during setting content
        ' ? "NO CELL id", id
        m.log.error("could not find cell to release", id)
      end if

    end function
  end class
end namespace
