import "pkg:/source/ml/ItemViewManager.bs"
import "pkg:/source/ml/ListMixin.bs"

namespace ml
  class ListItemViewManager extends ml.ItemViewManager

    private batchTimer as mc.types.node
    private visibleComponents = []

    private isUpdating = false
    private previousFocusedRow as mc.types.node
    private previousFocusedIndex = 0
    private isShowingAllComps = false
    ' public componentBufferMode = "rendered"
    public componentBufferMode = "none"

    public override function reset()
      m.log.info ("resetting viewManager. numItems: ", m.numberOfItems)

      if m.isRendering
        m.cancelBatching()
      end if

      if m.visibleComponents.count() > 0
        ? " RESETTING LIST COMPONENTS"
        m.log.info("releasing", m.visibleComponents.count(), "list children")
        for each component in m.visibleComponents
          component.content = invalid
        end for
        m.componentPool@.releaseComponents(m.visibleComponents)
      end if
      m.renderersByContentId = {}

      super.reset()
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ async row creation
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private creationIndex = -1
    'sometimes we want to create all rows up front, for important screens
    'using async renderer creation allows us to do this without clogging up the devices's render thread
    private batchSize = 3
    private batchDelay = 3

    function new(list as mc.types.node, container as mc.types.node, minPos as integer, maxPos as integer, componentPool as mc.types.node)
      super("ListItemViewManager", list, container, componentPool, 1, minPos, maxPos)
      m.delegate = list.rowEvents
      m.lookAheadDistance = maxPos * 5
      m.lookBehindDistance = maxPos * 2
    end function

    override function getRenderer(index as integer)
      return m.visibleComponents[index]
    end function

    private function cancelBatching()
      m.isRendering = false
      m.isUpdating = false
      'ensure that we catch any components if we were half way through a batch, so we can remove them
      allComponents = {}
      m.visibleComponents = []
      allComponents.append(m.previousRendereredByContentId)
      allComponents.append(m.renderersByContentId)
      for each id in allComponents
        m.visibleComponents.push(allComponents[id])
      end for
      m.cancelWaitTimer(m.batchTimer)
    end function

    override function createRenderers(content as mc.types.node, forceSync = false as boolean) as boolean

      ? "CREATE RENDERERS"
      m.visibleComponents = []
      m.visibleItems = []
      m.updateRects()
      if content <> invalid
        m.creationIndex = -1
        m.previousRendereredByContentId = m.renderersByContentId
        m.renderersByContentId = {}
        m.reusedRenderers = []
        m.visibleComponents = []
        m.listSettings = content.listSettings
        if not forceSync and m.listSettings.rowCreationStrategy = "async" and not m.isUpdating
          m.batchSize = m.listSettings.rowCreationBatchSize
          m.batchDelay = m.listSettings.rowCreationBatchDelay
          m.owner.state = "rendering"
          isReady = false
          m.batchTimer = m.waitAFrame(m.createRendererBatch, 0.15)
        else
          ' ? "USING SYNC MODE"
          m.batchSize = m.content.length
          isReady = true
        end if
        m.createRendererBatch()
        return isReady
      end if
      return false
    end function

    protected override function onRenderersCreated()
      super.onRenderersCreated()
      ' ? "TUR ::: LIST onRenderersCreated"
      m.tidyUpUnusedRenderers()
      if not m.isUpdating
        m.owner.state = "rendered"
        m.itemScroller.reset()
      else
        m.log.info("was updating, so not updating scroll position")
        'TODO - update the scrolling position if it was on a removed row
        m.isUpdating = false
      end if
      m.itemScroller.getComponentInfos(true)
      m.updateChangedItems()
      m.restorePreviousFocus()
    end function

    protected override function updateChangedItems()
      for each component in m.reusedRenderers
        'TODO - could consider optimizing further here by allowing rows to indicate they need updating
        component@.updateChangedItems()
      end for
    end function

    private function restorePreviousFocus()
      focusIndex = [0, 0]
      ' ? " RESTORE PRE FOCUS"
      if m.previousFocusedRow <> invalid
        ' ? " RESTORE PRE FOCUS AAA"
        row = m.renderersByContentId[m.previousFocusedRow.id]
        if row = invalid
          ' ? " RESTORE PRE FOCUS BBB"
          index = m.previousFocusedIndex < m.numberOfItems ? m.previousFocusedIndex : m.numberOfItems - 1
          row = m.visibleComponents[index]
        end if

        if row <> invalid
          ' ? " RESTORE PRE FOCUS CCC"
          focusIndex[0] = row.index
          focusIndex[1] = row.focusedCellIndex
        end if
      end if
      ' ? " RESTORE PRE FOCUS DDDD"
      m.previousFocusedIndex = 0
      m.previousFocusedRow = invalid
      ' 'TODO need to actually set the focus properly
      ' ? " RESTORE PRE FOCUS EEE " ;focusIndex[0]
      m.itemScroller.moveToIndex(focusIndex[0], false)
      ' ? " RESTORE PRE FOCUS : END"
      ' m.itemScroller.forceFocusOnIndex(focusIndex[0])
    end function

    override function createRendererBatch() as void
      if m.content <> invalid
        index = 0
        for i = 0 to m.batchSize
          ' m.log.info(">>> BEGIN CREATE ROW", i)
          m.creationIndex++
          index = m.creationIndex
          if m.creationIndex >= m.content.length
            ' ? "FINISHED RENDERING LIST ROWS"
            m.onRenderersCreated()
            return
          end if
          rowContent = m.content@.getChild(index)
          settings = ml.listMixin.getRowSettings(m.content, rowContent)
          rect = m.rects[index]

          comp = m.previousRendereredByContentId[rowContent.id]
          if comp <> invalid
            ' m.log.info("using comp for the same row")
            ' ? " REUSING COMP FOR SAME ROW "; index
            comp.index = index
            comp.translation = rect.translation
            comp.owner = m.owner
            m.reusedRenderers.push(comp)
            m.previousRendereredByContentId.delete(rowContent.id)
            'TODO do I need to set renderState
          else
            ' m.log.info("creating row for this item")
            comp = m.createRow(rowContent, index, settings, rect)
          end if


          if comp <> invalid
            m.visibleComponents.push(comp)
            m.renderersByContentId[rowContent.id] = comp
          else
            m.log.error("could not create row for index ")
          end if
          m.visibleComponents.push(comp)
          index++
          ' m.log.info(">>> END CREATE ROW", i)
        end for
        if m.creationIndex < m.content.length
          m.waitAFrame(m.createRendererBatch, 0.15)
        end if
      end if
    end function

    function createRow(rowContent as mc.types.node, index as integer, settings as mc.types.node, rect as mc.types.assocarray)
      compName = settings.componentName <> invalid ? settings.componentName : "ml_HorizontalRow"
      'TODO - measure height to ascertain how many
      isRendered = index < 4
      ' isRendered = true
      row = m.componentPool@.getComponent(compName, 1)
      m.renderersByContentId[rowContent.id] = row

      row.setFields(rect)

      ? " CREATING row "; index ; " isRendered" ; isRendered
      state = {
        renderState: isRendered ? "rendered" : m.componentBufferMode
        isRendered: isRendered
        owner: m.owner
        width: m.owner.width
        isInViewport: isRendered
      }
      row.setFields(state)
      m.container.appendChild(row)

      if row.isInitialized
        ' ? "RECYCLE EXISTING ROW"
        row@.recycle(rowContent)
        row.content = rowContent
      else
        ' ? "CREATE NEW ROW "
        row.content = rowContent
        row@._initialize(invalid)
      end if

      return row
    end function

    override function updateLayout(fullUpdate = false as boolean)
      ? " LIST UPDATE LAYOUT "; fullUpdate
      if fullUpdate
        ? " LUL A"
        'first check if any comps have changed type
        for i = 0 to m.rects.count() - 1
          ? " LUL B"
          rect = m.rects[i]
          comp = m.visibleComponents[i]
          if comp <> invalid and comp.content <> invalid and comp.subType() <> comp.content.settings.componentName
            if comp.getParent() <> invalid
              comp.getParent().removeChild(comp)
            end if
            comp = m.createRow(comp.content, comp.index, comp.content.settings, rect)
            m.visibleComponents[i] = comp
            m.renderersByContentId[comp.id] = comp
          end if
        end for
      end if

      m.updateRects()

      for i = 0 to m.rects.count() - 1
        rect = m.rects[i]
        comp = m.visibleComponents[i]
        if comp <> invalid
          comp.translation = rect.translation
          comp.visible = rect.visible
          if fullUpdate
            ? " >>>> DO FULL UPDATE on " ; mc.dv(comp)
            comp@.forceUpdate(true, fullUpdate)
          end if
        end if
      end for
    end function

    override function updateRects() as void
      y = 0
      w = m.owner.width
      m.rects = []
      m.visibleItems = []
      m.visibleComponents = []

      if m.content = invalid
        ? " INVALID CONTENT"
        return
      end if

      for i = 0 to m.content.length - 1
        item = m.content@.getChild(i)
        settings = ml.listMixin.getRowSettings(m.content, item)
        visible = item.isHidden <> true and (not settings.isHiddenWhenEmpty or item.length > 0)
        ? "ITEM " ; i ; " VISIBLE "; visible ; " L "; item.length ; " " ; item.length ; " isHidden " ; item.isHidden
        if visible
          if settings.subType() = "ml_GridRowSettings"
            height = m.calculateGridRowHeight(item, settings)
          else
            height = m.calculateRowHeight(settings)
          end if
          screenPos = settings.screenPos

          translation = [0, y]
          yOffset = 0
          contentOffset = settings.contentOffset
          if contentOffset <> invalid
            translation[0] += contentOffset[0]
            yOffset = contentOffset[1]
            translation[1] += yOffset
          end if

          height += settings.space + yOffset
          if settings.peekNextPixels <> 0
            screenPos = 1080 - (height + settings.peekNextPixels)
            settings.screenPos = screenPos
          end if

          y += height
        else
          height = 0
          screenPos = 0
          translation = [0, 0]
          ? " NOT VISIBLE"
        end if

        m.visibleItems.push(item)
        m.rects.push({
          translation: translation
          size: [w, height]
          index: i
          screenPos: screenPos
          visible: visible
        })
        comp = m.renderersByContentId[item.id]
        if comp <> invalid
          if comp.height = 0 or comp.height = -1
            comp.height = height
          end if
          m.visibleComponents.push(comp)
        end if
      end for

      m.numberOfItems = m.visibleItems.count()
      m.numberOfVisibleItems = m.visibleComponents.count()
    end function

    override function getFocusSettings()
      return m.content.focusSettings
    end function

    ' @params{ml_RowSettings} settings for the current row
    private function calculateRowHeight(settings as mc.types.node) as integer
      height = 300
      if settings = invalid
        return height
      end if

      if settings.height <> -1
        height = settings.height
      else if settings.cellSettings <> invalid
        height = settings.cellSettings.size[1]
      end if

      if settings.headerSettings.position <> "none"
        height += settings.headerSettings.height
      end if
      return height
    end function

    private function calculateGridRowHeight(row as mc.types.node, settings as mc.types.node) as integer
      numItems = row.length
      numCols = settings.numColumns
      numCols = numCols < 1 ? 1 : numCols
      numRows = mc.divideNumberToNearest(numItems, numCols)
      rowHeight = settings.rowHeight + settings.rowSpace
      height = numRows * rowHeight

      ' ? "+>+>+ GRID HEIGHT "; numItems ; "/" numCols ; " NR "; numRows ; " height " ; height
      if settings.headerSettings.position <> "none"
        height += settings.headerSettings.height
      end if
      return height
    end function

    protected override function onContentItemsChange(changes as mc.types.array)
      m.log.info("updating row renderers due to contents change")
      m.isUpdating = true
      m.previousFocusedRow = m.itemScroller.focusedItem
      m.previousFocusedIndex = m.itemScroller.index
      ' ? " GOT CHANGES "; formatJson(mc.collections.map(changes, function(c as object)
      '   return c.type
      ' end function))
      ? " AAA 1"
      m.createRenderers(m.content)
      ? " AAA 2 "
      m.itemScroller.processChanges(changes)
      ? " AAA 3 "
      m.itemScroller.move(0)
    end function

    override function isFlowFocusPossible(info as ml.componentInfo, direction as integer, activeScreenPos as integer)


      if info <> invalid and info.component <> invalid and info.component.subType() = "ml_GridRow"

        isFlowPossible = info.component@.isVerticalFlowFocusPossible(info, direction, activeScreenPos, m.container.translation[m.axes])
        ' ? "L>>>>>> GRID ROW " ; info.index ; " D " ; direction ; isFlowPossible
      else
        isFlowPossible = info.isFlowFocusPossible(m.container.translation[m.axes], m.maxPos, direction, m.axes)
      end if

      if not isFlowPossible and info.isFlowFocusAllowed
        'check on the renderer
        ' ? "Flow not possible based on component info - checking actual component " ; m.screenPos ; " NI "; info.index
        ' isFlowPossible = m.getIsOnScreen(info, activeScreenPos)
        isFlowPossible = m.getIsOnScreen(info, 0)
      end if
      ' end if

      return isFlowPossible
    end function

    public function getItemInfoForIndex(rowIndex as integer, cellIndex as integer)
    end function

    override function getIndexAtPosition(position as integer, direction as integer)
      p = abs(position)
      i = 0
      for i = 0 to m.itemScroller.componentInfos.count() - 1
        info = m.itemScroller.componentInfos[i]
        'the offset is already factored in
        itemPos = abs(info.getPosition(direction))
        ' itemPos = abs(info.getScrollOffset(direction))
        ' ? "i "; i ; " pos"; position ; " p "; p ; " ip " ; itemPos ; " INFO " ; info.index ; " c " ; mc.dv(info.component)
        if itemPos > p
          ' ? "+++++!!! MATCHED ITEM INDEX "; i - 1
          return mc.clamp(i - 1, 0, m.numberOfItems - 1)
        end if
      end for
      ' end ifk

      'we must be at the end! -return last item
      index = mc.clamp(i - 1, 0, m.numberOfItems - 1)
      ' ? "+++++!!! MATCHED ITEM INDEX "; index
      return index
    end function

  end class
end namespace
